package test

// Auto-generated tests for wealth-management stack
// Generated by: scripts/generate-tests.py
// DO NOT EDIT MANUALLY - regenerate with: make generate-tests

import (
	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
)

var terraformBinary = envOrDefault("TERRAFORM_BINARY_OVERRIDE", "terraform")

func envOrDefault(key, fallback string) string {
	if val := os.Getenv(key); val != "" {
		return val
	}
	return fallback
}

func configureTerraformOptions(opts *terraform.Options) *terraform.Options {
	if opts.EnvVars == nil {
		opts.EnvVars = map[string]string{}
	}
	opts.EnvVars["TERRAFORM_BINARY"] = terraformBinary
	return opts
}

func newTerraformOptions(t *testing.T, withRetry bool) *terraform.Options {
	base := &terraform.Options{
		TerraformDir: "../stacks/wealth-management",
		Vars: map[string]interface{}{
			"project_id":  "test-project",
			"environment": "dev",
		},
		NoColor: true,
	}
	if withRetry {
		base = terraform.WithDefaultRetryableErrors(t, base)
	}
	return configureTerraformOptions(base)
}

func shouldSkipApply() bool {
	return os.Getenv("CI_SKIP_TERRAFORM_APPLY") == "true"
}

func TestWealthManagementStackDeployment(t *testing.T) {
	t.Parallel()

	// Setup Terraform options
	terraformOptions := newTerraformOptions(t, true)
	applyChanges := !shouldSkipApply()
	if applyChanges {
		defer terraform.Destroy(t, terraformOptions)
	}

	// Run terraform init and plan
	terraform.Init(t, terraformOptions)
	planOutput := terraform.Plan(t, terraformOptions)

	// Verify plan contains expected resources
	require.Contains(t, planOutput, "Plan:")
	if !applyChanges {
		return
	}

	// Apply and validate
	terraform.Apply(t, terraformOptions)

	// Verify outputs exist
	outputs := terraform.OutputAll(t, terraformOptions)
	assert.NotEmpty(t, outputs)
}

func TestProjectServiceConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_project_service resources are properly configured
	require.NotEmpty(t, "required_apis", "Resource required_apis should be created")
}

func TestRandomIdConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify random_id resources are properly configured
	require.NotEmpty(t, "db_suffix", "Resource db_suffix should be created")
}

func TestSqlDatabaseInstanceConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_sql_database_instance resources are properly configured
	require.NotEmpty(t, "postgres", "Resource postgres should be created")
}

func TestSqlDatabaseConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_sql_database resources are properly configured
	require.NotEmpty(t, "wealth", "Resource wealth should be created")
}

func TestRandomPasswordConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify random_password resources are properly configured
	require.NotEmpty(t, "db_password", "Resource db_password should be created")
}

func TestSqlUserConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_sql_user resources are properly configured
	require.NotEmpty(t, "wealth_user", "Resource wealth_user should be created")
}

func TestStorageBucketConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_storage_bucket resources are properly configured
	require.NotEmpty(t, "frontend", "Resource frontend should be created")
	require.NotEmpty(t, "documents", "Resource documents should be created")
}

func TestStorageBucketIamMemberConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_storage_bucket_iam_member resources are properly configured
	require.NotEmpty(t, "public_read", "Resource public_read should be created")
	require.NotEmpty(t, "backend_access", "Resource backend_access should be created")
}

func TestStorageBucketObjectConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_storage_bucket_object resources are properly configured
	require.NotEmpty(t, "index", "Resource index should be created")
}

func TestServiceAccountConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_service_account resources are properly configured
	require.NotEmpty(t, "backend", "Resource backend should be created")
}

func TestCloudRunServiceConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_cloud_run_service resources are properly configured
	require.NotEmpty(t, "api", "Resource api should be created")
}

func TestCloudRunServiceIamMemberConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_cloud_run_service_iam_member resources are properly configured
	require.NotEmpty(t, "public_access", "Resource public_access should be created")
}

func TestProjectIamMemberConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_project_iam_member resources are properly configured
	require.NotEmpty(t, "sql_client", "Resource sql_client should be created")
}

func TestMonitoringDashboardConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_monitoring_dashboard resources are properly configured
	require.NotEmpty(t, "wealth_dashboard", "Resource wealth_dashboard should be created")
}

func TestLoggingProjectSinkConfiguration(t *testing.T) {
	t.Parallel()

	terraformOptions := newTerraformOptions(t, false)

	// Run terraform init and validate
	terraform.Init(t, terraformOptions)
	terraform.Validate(t, terraformOptions)

	// Verify google_logging_project_sink resources are properly configured
	require.NotEmpty(t, "wealth_logs", "Resource wealth_logs should be created")
}
