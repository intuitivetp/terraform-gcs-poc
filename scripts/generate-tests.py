#!/usr/bin/env python3
"""
Terraform Test Generator

Automatically generates Go tests for Terraform configurations based on
resources defined in the configuration.
"""

import json
import re
from pathlib import Path
from typing import Dict, List, Set
import argparse


class TestGenerator:
    """Generate Go tests for Terraform stacks"""
    
    def __init__(self, stack_dir: Path):
        self.stack_dir = stack_dir
        self.stack_name = stack_dir.name
        
    def generate_tests(self) -> str:
        """Generate complete test file"""
        # Parse Terraform files to extract resources
        resources = self._parse_terraform_files()
        
        # Generate test code
        code_parts = []
        code_parts.append(self._generate_header())
        code_parts.append(self._generate_imports())
        code_parts.append(self._generate_helpers())
        code_parts.append(self._generate_test_functions(resources))
        
        return "\n\n".join(code_parts)
    
    def _parse_terraform_files(self) -> Dict[str, List[str]]:
        """Parse Terraform files and extract resource types"""
        resources = {}
        
        for tf_file in self.stack_dir.glob("**/*.tf"):
            content = tf_file.read_text()
            
            # Find resource blocks
            pattern = r'resource\s+"([^"]+)"\s+"([^"]+)"'
            matches = re.findall(pattern, content)
            
            for resource_type, resource_name in matches:
                if resource_type not in resources:
                    resources[resource_type] = []
                resources[resource_type].append(resource_name)
        
        return resources
    
    def _generate_header(self) -> str:
        """Generate file header"""
        return f'''package test

// Auto-generated tests for {self.stack_name} stack
// Generated by: scripts/generate-tests.py
// DO NOT EDIT MANUALLY - regenerate with: make generate-tests'''
    
    def _generate_imports(self) -> str:
        """Generate import statements"""
        return '''import (
\t"os"
\t"testing"
\t"github.com/gruntwork-io/terratest/modules/terraform"
\t"github.com/stretchr/testify/assert"
\t"github.com/stretchr/testify/require"
)'''
    
    def _generate_helpers(self) -> str:
        """Generate shared helper functions"""
        return '''var terraformBinary = envOrDefault("TERRAFORM_BINARY_OVERRIDE", "terraform")

func envOrDefault(key, fallback string) string {
\tif val := os.Getenv(key); val != "" {
\t\treturn val
\t}
\treturn fallback
}

func configureTerraformOptions(opts *terraform.Options) *terraform.Options {
\tif opts.EnvVars == nil {
\t\topts.EnvVars = map[string]string{}
\t}
\topts.EnvVars["TERRAFORM_BINARY"] = terraformBinary
\treturn opts
}

func newTerraformOptions(t *testing.T, withRetry bool) *terraform.Options {
\tbase := &terraform.Options{
\t\tTerraformDir: "../stacks/%s",
\t\tVars: map[string]interface{}{
\t\t\t"project_id":  "test-project",
\t\t\t"environment": "dev",
\t\t},
\t\tNoColor: true,
\t}
\tif withRetry {
\t\tbase = terraform.WithDefaultRetryableErrors(t, base)
\t}
\treturn configureTerraformOptions(base)
}

func shouldSkipApply() bool {
\treturn os.Getenv("CI_SKIP_TERRAFORM_APPLY") == "true"
}''' % self.stack_name

    def _generate_test_functions(self, resources: Dict[str, List[str]]) -> str:
        """Generate test functions for each resource type"""
        tests = []
        
        # Main integration test
        tests.append(self._generate_integration_test(resources))
        
        # Resource-specific tests
        for resource_type, resource_names in resources.items():
            tests.append(self._generate_resource_test(resource_type, resource_names))
        
        return "\n\n".join(tests)
    
    def _generate_integration_test(self, resources: Dict[str, List[str]]) -> str:
        """Generate main integration test"""
        resource_count = sum(len(names) for names in resources.values())
        stack_name_camel = self._to_camel_case(self.stack_name)
        output_assertions = self._generate_output_assertions()
        
        return f'''func Test{stack_name_camel}StackDeployment(t *testing.T) {{
\tt.Parallel()

\t// Setup Terraform options
\tterraformOptions := newTerraformOptions(t, true)
\tapplyChanges := !shouldSkipApply()
\tif applyChanges {{
\t\tdefer terraform.Destroy(t, terraformOptions)
\t}}

\t// Run terraform init and plan
\tterraform.Init(t, terraformOptions)
\tplanOutput := terraform.Plan(t, terraformOptions)

\t// Verify plan contains expected resources
\trequire.Contains(t, planOutput, "Plan:")
\tif !applyChanges {{
\t\treturn
\t}}

\t// Apply and validate
\tterraform.Apply(t, terraformOptions)

\t// Verify outputs exist
\t{output_assertions}
}}'''
    
    def _generate_output_assertions(self) -> str:
        """Generate assertions for stack outputs"""
        return '''outputs := terraform.OutputAll(t, terraformOptions)
\tassert.NotEmpty(t, outputs)'''
    
    def _generate_resource_test(self, resource_type: str, resource_names: List[str]) -> str:
        """Generate test for specific resource type"""
        test_name = self._resource_type_to_test_name(resource_type)
        
        assertions = []
        for name in resource_names:
            assertions.append(f'\trequire.NotEmpty(t, "{name}", "Resource {name} should be created")')
        
        assertions_str = "\n\t".join(assertions) if assertions else '\t// No specific assertions'
        
        return f'''func Test{test_name}Configuration(t *testing.T) {{
\tt.Parallel()

\tterraformOptions := newTerraformOptions(t, false)

\t// Run terraform init and validate
\tterraform.Init(t, terraformOptions)
\tterraform.Validate(t, terraformOptions)

\t// Verify {resource_type} resources are properly configured
{assertions_str}
}}'''
    
    def _resource_type_to_test_name(self, resource_type: str) -> str:
        """Convert resource type to test function name"""
        # google_storage_bucket -> StorageBucket
        parts = resource_type.replace("google_", "").split("_")
        return "".join(p.capitalize() for p in parts)
    
    def _to_camel_case(self, s: str) -> str:
        """Convert string to CamelCase"""
        return "".join(word.capitalize() for word in s.replace("-", "_").split("_"))


def main():
    parser = argparse.ArgumentParser(
        description="Generate Go tests for Terraform stacks"
    )
    parser.add_argument(
        "stack_dir",
        type=Path,
        help="Path to stack directory"
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        help="Output test file"
    )
    
    args = parser.parse_args()
    
    if not args.stack_dir.exists():
        print(f"Error: Stack directory not found: {args.stack_dir}")
        return 1
    
    # Generate tests
    generator = TestGenerator(args.stack_dir)
    test_code = generator.generate_tests()
    
    # Determine output file
    if args.output:
        output_file = args.output
    else:
        # Convert dashes to underscores for Go-compatible filenames
        stack_name = args.stack_dir.name.replace("-", "_")
        output_file = Path("tests") / f"{stack_name}_generated_test.go"
    
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(test_code)
    
    print(f"✅ Generated tests: {output_file}")
    print(f"📝 {len(test_code.split('func Test'))-1} test functions created")
    
    return 0


if __name__ == "__main__":
    exit(main())
